#!/usr/bin/env python3
"""
iload.py - Serial loader for text, Intel HEX, WOZ, and binary files.

Features:
- Auto-detect input lines: Intel HEX, WOZ, or plain text
- Binary mode: binary -> Intel HEX or WOZ (start address required)
- Optional WOZ output format (-w / --woz)
- WOZ input: syntax check only, sent verbatim
- Configurable baud rate, delay, line endings
- Optional CTRL-Z EOF (--eof)
- Uses pyserial
"""

import sys
import time
import argparse
import re
import serial
import os

# ---------- Regex patterns ----------
HEX_RE = re.compile(r"^:[0-9A-Fa-f]+$")
WOZ_RE = re.compile(r"^[0-9A-Fa-f]+:\s*(?:[0-9A-Fa-f]{2}\s*)*$")

# ---------- Intel HEX helpers ----------
def parse_intel_hex(line):
    try:
        raw = bytes.fromhex(line[1:])
    except ValueError:
        return None

    if (sum(raw) & 0xFF) != 0:
        return None

    length = raw[0]
    addr = (raw[1] << 8) | raw[2]
    rectype = raw[3]
    data = raw[4:4 + length]
    return rectype, addr, data

def make_hex_line(addr, data):
    ll = len(data)
    rec = [ll, (addr >> 8) & 0xFF, addr & 0xFF, 0x00] + list(data)
    checksum = (-sum(rec)) & 0xFF
    return ":" + "".join(f"{b:02X}" for b in rec) + f"{checksum:02X}"

# ---------- WOZ helpers ----------
def parse_woz(line):
    if not WOZ_RE.match(line):
        return None
    try:
        addr_str, data_str = line.split(":", 1)
        addr = int(addr_str.strip(), 16)
        data = bytes(int(b, 16) for b in data_str.split())
    except ValueError:
        return None
    return addr, data

def make_woz_line(addr, data):
    return f"{addr:04X}: " + " ".join(f"{b:02X}" for b in data)

# ---------- Main ----------
def main():
    parser = argparse.ArgumentParser(description="Serial loader (HEX / WOZ / binary)")

    parser.add_argument("textfile", nargs="?", help="Input file (default: stdin)")
    parser.add_argument("-p", "--port", default="/dev/ttyUSB0", help="Serial port")
    parser.add_argument("--baud", type=int, default=115200, help="Baud rate")
    parser.add_argument("-d", "--delay", type=float, default=5, help="Delay (ms)")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    parser.add_argument("-b", "--binary", metavar="ADDR",
                        help="Binary mode: start address (hex required)")
    parser.add_argument("-w", "--woz", action="store_true",
                        help="Output WOZ format instead of Intel HEX")

    parser.add_argument("--eof", action="store_true",
                        help="Send CTRL-Z (0x1A) after transfer")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("-c", "--crlf", action="store_true")
    group.add_argument("-l", "--lf", action="store_true")
    group.add_argument("-r", "--cr", action="store_true")

    args = parser.parse_args()
    delay = args.delay / 1000.0

    if args.crlf: newline = b"\r\n"
    elif args.lf: newline = b"\n"
    elif args.cr: newline = b"\r"
    else: newline = b"\n"

    try:
        ser = serial.Serial(args.port, args.baud, timeout=1, write_timeout=1)
    except serial.SerialException as e:
        print(f"Serial error: {e}", file=sys.stderr)
        sys.exit(1)

    if args.verbose:
        print(f"[VERBOSE] {args.port} @ {args.baud}", file=sys.stderr)

    # ---------- Binary mode ----------
    if args.binary:
        try:
            addr = int(args.binary, 16)
        except ValueError:
            print("Invalid binary start address", file=sys.stderr)
            sys.exit(1)

        data = (open(args.textfile, "rb").read()
                if args.textfile else sys.stdin.buffer.read())

        for i in range(0, len(data), 16):
            chunk = data[i:i + 16]
            line = make_woz_line(addr, chunk) if args.woz else make_hex_line(addr, chunk)

            ser.write(line.encode() + newline)
            ser.flush()
            if args.verbose:
                print(line)
            addr += len(chunk)
            time.sleep(delay)

        if not args.woz:
            ser.write(b":00000001FF" + newline)

        if args.eof:
            ser.write(b"\x1A")

        ser.close()
        return

    # ---------- Text / HEX / WOZ input ----------
    infile = open(args.textfile) if args.textfile else sys.stdin

    for lineno, line in enumerate(infile, 1):
        line = line.rstrip("\r\n")

        # Intel HEX
        if HEX_RE.match(line):
            if args.verbose:
                print(f"HEX: ", line, file=sys.stderr)
            parsed = parse_intel_hex(line)
            if not parsed:
                print(f"Warning: bad HEX at line {lineno}", file=sys.stderr)
                continue
            rectype, addr, data = parsed
            if rectype == 0x00:
                out = make_woz_line(addr, data) if args.woz else line
            elif not args.woz and rectype == 0x01:
                out = line
            else:
                continue

        # WOZ (syntax check only, no conversion)
        elif WOZ_RE.match(line):
            if args.verbose:
                print(f"WOZ: ", line, file=sys.stderr)
            if not parse_woz(line):
                print(f"Warning: bad WOZ at line {lineno}", file=sys.stderr)
            out = line

        # Plain text
        else:
            if args.verbose:
                print(f"TXT: ", line, file=sys.stderr)
            out = line

        ser.write(out.encode(errors="replace") + newline)
        ser.flush()
        time.sleep(delay)

    if args.eof:
        ser.write(b"\x1A")

    ser.close()

if __name__ == "__main__":
    main()

