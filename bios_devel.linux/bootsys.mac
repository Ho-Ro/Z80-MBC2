; SPDX-License-Identifier: GPL-2.0-or-later

	title	BOOTSYS	- CPM3.SYS 1.20
	subttl	Copyright (C) 2000,2014 Andreas Gerlich

;------------------------------------------------------------------------------
; BOOTSYS relocates and places the resident and banked (if present) parts
; of a CPM3.SYS to their right places into memory and starts CP/M 3.1.
; You generate a cpm3.com for starting CP/M 3.1 with:
;	pip cpm3.com=bootsys.com,cpm3.sys
;
; Copyright (C) Andreas Gerlich (Andreas.Gerlich@mathematik.uni-ulm.de)
;
; BOOTSYS is free software; you can redistribute it and/or modify it under
; the terms of the GNU General Public License as published by the Free
; Software Foundation; either version 2 of the License, or (at your
; option) any later version.
;
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
;
; BOOTSYS WILL NOT WORK ON ALL CP/M 3.1 SYSTEMS. Why?
; If the MOVE, XMOVE are placed in the banked part of the BIOS then it is
; possible for those routines to be overwritten when bootsys+cpm3.sys are
; transferred to bank 0.
;
; Try it.  If this utility works under your CP/M 3 system then you can start
; a new version of your system from the current one without having to write
; it to the system tracks.
;
; Bootsys works always under CP/M 2.2 to relocate and start a nonbanked or
; a banked CP/M 3.1.
;
; You generate a cpm3.com for starting CP/M 3.1 with:
;	pip cpm3.com=bootsys.com,cpm3.sys
;-----------------------------------------------------------------------------
; 2014-01-14 Jon Saxton
; .  Added many comments in English. Shortened and/or corrected some messages.
; .  Fixed bug in XMOVE/MOVE sequence of calls.
; .  Adjusted calculation of CPM3.SYS location.
; .  Updated version number and copyright notice.
;
; Some explanation of the XMOVE/MOVE change is warranted.
;
; The original code moved (or tried to move) a large block of code from
; bank 1 to bank 0 and then executed that code in bank 0.  It did this
; with three BIOS calls:
;	XMOVE		to set the source and destination banks
;	MOVE		to actually copy the code
;	SELMEM		to switch to bank 0
; The addresses of those three BIOS routines are calculated but the Z80 has
; no instruction to call a computed address so the program stacked the three
; return addresses and at the appropriate locations simply executed a jp (hl)
; instruction.
;
; That approach works in YAZE-AG because the memory management is done in the
; emulator code rather than in CP/M.  On real hardware it is generally doomed
; because of the way that inter-bank transfers are implemented.
;
; The description of the XMOVE routine in the CP/M 3 System Guide states:
;	"After a call to XMOVE function, the following call to the MOVE
;	 function is not more than 128 bytes of data."
; Without special hardware (namely a DMA controller capable of doing inter-
; bank memory transfers) XMOVE must be inplemented using a small buffer in
; common memory, typically one generated by GENCPM for the purpose.  The
; large transfer done by BOOTSYS overruns that buffer and effectively
; DEstroys everything in memory.
;
; While it is certainly possible to implement a large-transfer inter-bank
; MOVE in the BIOS that is generally not done because of the aforementioned
; assurance that at most 128 bytes would be copied between memory banks.
; It was necessary to modify BOOTSYS so that it would call XMOVE and MOVE as
; often as necessary, copying 128 bytes at a time.
;
; Clearly the return-address-stacking method of perfoming computed calls
; is impractical when an indeterminate number of calls needs to be made to
; XMOVE and MOVE.  Fortunately there is a simple workaround; it is as easy
; as this:
;
;	compute	hl,<address>	; Subroutine address to hl
;	call	@hl		; Call surrogate routine
;	...
;
; @hl:
;	jp	(hl)		; Execute function 
;
; Obviously the first line is not a real instruction; it just represents some
; sequence of operations which leave the target subroutine address in hl.
;
; In practice I put some more stuff in the surrogate routine to save code
; duplication so the code in this source file is a bit more elaborate.
;
;-----------------------------------------------------------------------------
;
; Ho-Ro	20260113: Modification for Z80-MBC2-NG with banked cout.
;	Do not use BIOS cout but send output directly to IOS.
; Ho-Ro	20260117: BOOTSYS.COM can now run also stand-alone and loads the file
;	that is given as cmd line argument, checks for correct CPM3.SYS format
;	and executes this file.
;
;-----------------------------------------------------------------------------
	if2
	.printx	'BOOTSYS - CPM3.SYS 2.00'
	endif

true	equ	-1
false	equ	not true

yaze	equ	false

	include iosopcod.lib	; IOS-Z80-MBC2 opcode equates

	.z80	; Code uses Z80 instructions

cr	equ	13
lf	equ	10
ht	equ	 9
quote	equ	22h

	aseg
	org	100h

begin:	jp	main


CR	equ	0dh
LF	equ	0ah

Copyright_message:
	db	cr,lf
	db	'BOOTSYS - CPM3.SYS - 2.0.260117'
    ifdef	LINUX
	db	' (LINUX TEST)'
    endif
	db	cr,lf
	db	'$'

;
;---------------------------------------------------------------------------

wboot		equ	0
wbootvek	equ	wboot+1
bdos		equ	5
bdosvek		equ	bdos+1
cpmfcb		equ	wboot+5ch
parameter	equ	wboot+80h

;----------------------------------------------------------------------------
; Call a BIOS function.
;
; Load the relevant registers and use the BIOS macro to invoke the function.
;----------------------------------------------------------------------------

bios	macro	func
	ex	af,af'		; Save A register
	ld	a,func*3-3	; Offset into BIOS vector
	call	goBIOS		; Invoke BIOS function
	endm

goBIOS:
	push	de		; Save de while we compute
	ld	iy,(wbootvek)	; Get BIOS warm boot address
	ld	e,a		; Form 16-bit addend
	ld	d,0
	add	iy,de		; Function address now in IY
	pop	de		; Restore de
	ex	af,af'		; Restore A
	jp	(iy)

; BDOS function codes
CONOUT	EQU	2		;CONSOLE OUTPUT
OPEN	EQU	15		;OPEN FUNCTION CODE
READ	EQU	20		;READ FUNCTION
STDMA	EQU	26		;SET BUFFER ADDRESS FUNCTION CODE

; BIOS function codes
SELMEM	equ	27
MOVE	equ	25
XMOVE	equ	29


;----------------------------------------------------------------------------

	; MAIN

main:	ld	sp,lstack	; Stack setzten

	; CP/M Vektoren ueberpruefen
	; Check CP/M vectors
	ld	a,0C3h		; OP-Code fuer jp

	ld	(cpmvek),a	; Boolsche Variable "CP/M Vektoren" setzen.
				; (Ab jetzt werden Ein-/Ausgaben ueber das
				; BIOS getaetigt.)

	ld	sp,(bdosvek)	; Stack auf top von TPA setzen
				; Stack at top of TPA.
	ld	hl,(wbootvek)	; Warmbootvektor absichern (wird ab jetzt
	ld	(wbvektor),hl	;	   bei Character in/out verwendet !)

	; CP/M Vektoren sind vorhanden
	; --> ueberpruefen ob ein Parameter gegeben wurde

	ld	hl,Copyright_message	; Copyright message ausgeben
	call	PRSTRfunc		; Display copyright message


	; Copyright Message von Digital Research in CPM3.SYS ueberpruefen

	call	testcopyright	; CPM3.SYS appended to this file?
	jr	z,testecpmversion ; yes

checkarg:
	ld	a,(cpmfcb+1)	; file as cmd line parameter?
	cp	' '		; valid FCB?
	jr	nz,loadfile	; yes, load and check for CPM3.SYS format

	ld	hl,nocopyright1 ; no, FCB is empty
	call	PRSTRfunc
	jp	wboot

loadfile:
	call	loadcpmsys	; load file argument, check if cpm3.sys format

testecpmversion:
	ld	a,(cpmvek)	; Sind CP/M Vektoren vorhanden?
	or	a
	jr	z,loadcpm3	; Nein --> gleich CP/M 3 laden

	; CP/M Version testen

	ld	c,12		; Versionsnummer von CP/M holen
	call	bdos

	ld	a,l
	and	30h		; nur oberer Teil beruecksichtigen
	cp	30h
	jr	nz,loadcpm3	; ungleich Version 3x --> CPM3.SYS sofort laden

	; wenn CP/M 3.1 bereits laeuft
	; XMOVE ueberpruefen

	ld	de,28*3		; -1 wegen Warmboot, 29 ist Position von XMOVE
	ld	hl,(wbootvek)	; hole Adresse von Warmboot
	add	hl,de		; HL points to the xmove-jmp in bios-table
	inc	hl		; points to jmp address
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a		; HL points to the xmove routine itself

	; now test if ret instruction is available for xmove-routine

	ld	a,0C9h		; ret-Opcode
	cp	(hl)
	jp	nz,MoveToBank0	; No ret --> xmove available --> all to bank 0

	ld	hl,no_xmove_message
	call	PRSTRexit

	; XMOVE seems to be implemented
	; --> try to move all to bank 0

MoveToBank0:
	ld	hl,bank1_message
	call	PRSTRfunc

; ---------------     NEW CODE     ---------------
;|    |    |    |		  |    |    |    |
;v    v    v    v		  v    v    v    v


	; The next six lines were copied from the original code ...
	ld	ix,CPM3SYS	; dort beginnt CPM3.SYS
	ld	a,(ix+reslen)
	add	a,(ix+bnklen)	; Gesamtlaenge <reslen> + <bnklen> berechnen
				; Calculate total length (resident + banked)
	ld	bc,CPM3SYS	; dort beginnt CPM3.SYS
	add	a,b		; += Offset vom CPM3.SYS Binary
	ld	b,a		; BC = <reslen> + <bnklen> + Offset CPM3.SYS

	; We need to move this entire program plus the attached CPM3.SYS
	; from the current bank (1) to the system bank (0).  We do it in
	; a series of 128-byte interbank moves.
	;
	; BC contains the total number of bytes which need to be copied.
	; It is known to be an exact multiple of 128 bytes so a test for
	; BC=0 is sufficient to detect the end of the transfer.

	ld	hl,100h		; Destination address in bank 0
	ld	d,h		; Same source address in bank 1
	ld	e,l
copy128:
	ld	a,b		; See if move is finished. This test is valid 
	or	c		; because BC was originally a multiple of 128
	jr	z,bank0
	push	bc		; Save byte count
	ld	bc,0001h	; B=destination bank (0), C=source bank (1)
	bios	XMOVE		; Set up for inter-bank move
	ld	bc,128		; Number of bytes to move
	push	bc		; Save for subtract
	bios	MOVE
	; According to the CP/M 3 System Guide DE and HL should now point at
	; the bytes immediately beyond those that were copied.  This means
	; that the pointers are ready for the next call to MOVE.
	exx			; Save source and destination
	pop	de		; Subtrahend
	pop	hl		; Byte count
	or	a		; Clear carry flag
	sbc	hl,de		; Decrement bytes to move
	push	hl		; Stack it
	exx			; Recover source and destination pointers
	pop	bc		; Recover remaining bytes
	jr	copy128
bank0:
	xor	a		; Set bank 0
	bios	SELMEM

;^    ^    ^    ^		  ^    ^    ^    ^
;|    |    |    |		  |    |    |    |
; ---------------     NEW CODE     ---------------


;---------------------------------------------------------------------------

	nop	; now this instruction will be executed in bank 0

;---------------------------------------------------------------------------

	ld	hl,bank0_message
	call	PRSTRfunc

;---------------------------------------------------------------------------
; Hier beginnt der eigentliche Lader fuer CPM3.SYS.
; This is the start of the actual CPM3.SYS loader.
;---------------------------------------------------------------------------
;
; The following information is from page 115 Appendix D of the System Guide
;
;
; CPM3.SYS File Format:
;
;	0	Header Record (128 bytes)
;	1	Print Record (128 bytes)
;	2-n	CP/M 3 operating System in reverse order, top down.
;
;
; Header Record Definitions:
;
; CPM3.SYS (see at the end) ; Start of CPM3.SYS

restop	equ	0	; Top page plus one, at which the resident partion
			; of CP/M 3 is to be loaded top down.

reslen	equ	1	; Length in pages (256 bytes) of the resident
			; portion of CP/M 3.

bnktop	equ	2	; Top page plus one, at which the banked portion
			; of CP/M 3 is to be loaded top down.

bnklen	equ	3	; Length in pages (256 bytes) of the banked
			; portion of CP/M 3.

coldboot equ	4	; Address of CP/M 3 Cold Boot entry point

copyrmsg equ	16	; Copyright Message



; Print Record:
;
; The Print Record in the CP/M 3 Load Table is ASCII,
; terminated by a dollar sign ($).

prrecord equ	128	; position of the Print Record

;---------------------------------------------------------------------------

zwsp	equ	80h
zwsptop	equ	zwsp+127; letztes Byte in Zwischenspeicher
			; Last byte in buffer

; Kleiner Hinweis:	Wenn ich von "oberen Bereich" spreche, so ist damit
;			der Teil gemeint der adressmaessig weiter oben liegt
;			Dasselbe analog bei der Bezeichnung "unterer Teil".
;
; Note:			When I say "upper range" I am referring to the 
;			addresses above.  Analogous reasoning applies for
;			"lower portion".

loadcpm3:
	ld	hl,loadmsg	; Text "Loading ..." ausgeben
	call	PRSTRfunc	; Emit "Loading ..."

	ld	hl,CPM3SYS+prrecord	; Printrekord ausgeben
	call	PRSTRfunc		; Emit print record

	ld	sp,lstack	; Nach allen Ausgaben Stack wieder
				; auf local stack setzten


    ifdef	LINUX
	ld	hl,LINUXmsg
	jp	PRSTRexit	; HACK
LINUXmsg:
	db	cr,lf
	db	'LINUX test -> exit.'
	db	cr,lf,lf
	db	'$'
    endif

	; Zuerst den residenten Teil kopieren.
	; Im SPR-Format sind alle Sektoren Seiten-Buendig in 128 Byte
	; Bloecken (log Sektor) abgelegt. Die Ablage erfolgte jedoch
	; upside-down, d.H. der letzte Sektor wird zuerst gelesen.
	;
	; First copy the resident portion.  In the .SPR format 128-byte
	; records are stored adjacent but upside-down; i.e. the last
	; sector is read first.

	ld	ix,CPM3SYS	; dort beginnt CPM3.SYS
	ld	d,(ix+restop)
	ld	e,0		; DE <- top of resident part (<restop>)
	ld	a,(ix+reslen)	; LEN of resident part (in 256-byte pages)
	add	a,a		; *2 = Anzahl der log Sektoren (128 Byte)
				; Muss mal 2 genommen werden da in <reslen>
				; die Anzahl von 256 Byte Pages abgelegt ist.
				; Double the number of pages to convert to
				; 128-byte blocks.
	ld	hl,CPM3SYS+100h ; Zeiger auf 2. Record (1. Binary of CP/M 3)

	call	transfer	; A=Bloecke von (HL)-->(DE) (upside down)


	; HL zeigt nun auf den Begin des banked Teils und somit
	; auf den erster log. Sektor des unteren Bereichs
	;
	; HL now points to the start of the banked portion and thus to
	; the first logical sector of the lower part.

	push	hl		; Fuer Berechnung auf Stack

	exx			; 2 Registersatz fuer oberen Bereich

	pop	hl		; HL <- zeiger auf banked part

	ld	a,(ix+bnklen)	; LEN of banked part (<bnklen>)
	or	a		; Ist die Laenge fuer banked part 0
	jr	z,bootcpm3	; ja --> nonbanked System sofort booten

	; Wenn nein, banked part laden
	; Non-zero banked length; load the banked part

	add	a,h		; oberste page berechnen
				; Calculate the top page
	ld	h,a		; HL zeigt genau hinter den obersten
				; Sektor (banked part)
				; HL points just beyond the top sector
				; of the banked part
	dec	hl		; HL zeigt auf das letzte Byte des
				; DEs obersten log. Sektors

	ld	a,(ix+bnklen)	; LEN of banked part (<bnklen> 256 Byte pages)
				; (zum zaehlen)

	; Dieser Zaehler darf NICHT *2 genommen werden so wie oben.
	; Folgende Grafik verdeutlicht den Vorgang:
	;
	;
	;				+----------+<----<<--+
	;				| zwsp	   |-->>+    |
	;				+----------+	|    |
	;					     (3)|    |
	;						|    |
	;						|    |
	; Begin banked Bereich -------> +----------+<-<<+    |
	;  (unterer Bereich)	  ^	| page 0   |->>-+    |
	;			 256	+----------+	|    |(1)
	;			  |	| page 1   |	|    |
	;			-----	+----------+	|    |
	;				    ... 	|    |
	;				    ...      (2)|    |
	;				    ... 	|    |
	;				    ... 	|    |
	;				+----------+	|    |
	;				| page n-1 |	|    |
	;				+----------+<-<<+    |
	;  (oberer Bereich)		| page n   |----->>--+
	; End banked Bereich ---------> +----------+
	;
	;
	; Ein Austauschzyklus besteht aus den Schritten:
	;
	; (1) 128 Bytes vom oberen Bereich in den Zwischenspeicher
	; (2) 128 Bytes vom unteren Bereich in den oberen Bereich
	; (3) 128 Bytes vom Zwischenspeicher in den unteren Bereich
	; (4) Pointer unterer Bereich um +128 erhoehen
	;     Pointer oberer Bereich um -128 erniedrigen
	;     (Der Vorgang des Pointerverschiebens erfolgt automatisch
	;      ueber die Pointer der Befehle LDDR und LDIR.)
	;
	; Es werden also n/2 Vertauschungen gemacht und die Pointer treffen
	; sich genau in der Mitte (oberer Bereich wird mit dem unteren
	; Bereich spiegelverkehrt ausgetauscht). Wobei gilt <bnklen> = n/2.
	; Der Wert aus <bnklen> darf fuer den Austauschvorgang also
	; unveraendert benutzt werden, da hier genau die obere Haelfte mit
	; DEr unteren Haelfte spiegelverkehrt ausgetauscht wird.
	;------------------
	; The numerator should NOT be taken as *2 above.
	; The following diagram illustrates the process:
	;
	;
	;				+----------+<----<<--+
	;				| zwsp	   |-->>+    |
	;				+----------+	|    |
	;					     (3)|    |
	;						|    |
	;						|    |
	; Begin banked Bereich -------> +----------+<-<<+    |
	;  (unterer Bereich)	  ^	| page 0   |->>-+    |
	;			 256	+----------+	|    |(1)
	;			  |	| page 1   |	|    |
	;			-----	+----------+	|    |
	;				    ... 	|    |
	;				    ...      (2)|    |
	;				    ... 	|    |
	;				    ... 	|    |
	;				+----------+	|    |
	;				| page n-1 |	|    |
	;				+----------+<-<<+    |
	;  (oberer Bereich)		| page n   |----->>--+
	; End banked Bereich ---------> +----------+
	;
	;
	; The loop comprises the following steps:
	;
	; (1) 128 bytes from the upper region into the intermediate area
	; (2) 128 Bytes from the lower region to the upper region
	; (3) 128 Bytes from intermediate storage to the lower portion
	; (4) Increment the lower address pointer by 128
	;     Decrement the upper address pointer by 128
	;     (The pointer adjustments done automatically by LDDR and LDIR.)
	;
	; n/2 exchanges are made and the the pointers are left in the middle
	; of the range.  The effect is a mirror reordering of the code.  Bear
	; in mind that the number of logical sectors swapped is <bnklen> so
	; that value can be used unchanged.
	;
	;--------------

loop:
	; HL zeigt auf das letzte Byte des oberen Teils (updown)
	; oberen Teil in den scratch Bereich
	; HL is the last byte of the upper part of the scratch area.

	ld	de,zwsptop	; letztes Byte des Zwischenspeichers
				; Last byte of the buffer
	ld	bc,128		; 128 Bytes
	lddr			; transferiere nach zwsp 128 Bytes rueckwaerts
				; Transfer 128 bytes backwards

	; HL zeigt auf letztes Byte des vorherigen Sektors
	; HL points to the last byte of the previous sector

	push	hl		; fuer den naechsten move als zieladresse
				; absichern
				; Save HL as destination address for the
				; next move 
	exx

	; HL zeigt auf die source vom unteren Teil (lowup)
	; unteren Bereich in den oberen Bereich verschieben
	; HL is the source from the lower region.
	; Move from lower to upper.
	push	hl		; wird gleich nochmal benoetigt
	pop	iy		; ins IY

	pop	de
	inc	de		; DE zeigt auf ziel
				; DE points at target

	ld	bc,128		; 128 Bytes
	ldir			; vorwaerts transferieren

	; vom scratchbereich transferieren
	; Transfer from intermediate buffer

	push	iy		; hole pointer auf unteren Bereich (lowup)
	pop	de		; als destination

	ld	hl,zwsp		; scratch Bereich
	ld	bc,128		; 128 Bytes
	ldir

	; DE steht auf naechstem Sektor vom unteren Teil (lowup)

	ex	de,hl		; HL steht auf dem naechsten Sektor.
				; Wird fuer den naechsten move in HL
				; erwartet
	exx

	; Nun sind beide Sektoren vertauscht. (Sectors are swapped.)
	; HL und HL' stehen jeweils auf den naechsten log Sektor:
	; HL and HL' are ready for the next logical sector swap:
	; HL' (um 128 Bytes hoeher [higher])
	; HL  (um 128 Bytes niedriger [lower])

	dec	a		; --A, ist letzter Sektor vertauscht?
	jr	nz,loop		; nein --> loop

; Damit liegt der code in der richtigen Reihenfolge vor. Jetzt muss er
; nur noch an die richtige Stelle transferiert werden und ins Bios
; eingesprungen werden.
;
; The code is in the correct order.  Now it must be transferred to the
; correct place and control given to the BIOS.

	ld	hl,CPM3SYS+0100h ; Beginn vom CPM3 binary

	ld	a,(ix+reslen)
	add	a,(ix+bnklen)	; Gesammtlaenge <reslen> + <bnklen> berechnen

	add	a,h		; += Offset vom CPM3 Binary
	ld	h,a
	dec	hl		; HL steht auf dem letzten Byte des
				; banked Parts
				; HL -> last byte of the banked part
	ld	d,(ix+bnktop)
	ld	e,0
	dec	de		; DE zeigt auf (<bnktop>*256)-1, also ein
				; Byte vor COMMON Memory
				; DE points at (<bnktop>*256)-1, i.e. one
				; byte below common memory

	ld	b,(ix+bnklen)
	ld	c,0		; BC beinhaltet die Laenge vom banked Bereich
				; BC holds the length of the banked portion

	lddr			; und transferieren von oben her


; Damit sollte der Code in der richtigen Reihenfolge an der richtigen
; Position stehen.
; Jetzt CP/M 3 booten (BIOS einspringen):

bootcpm3:
	ld	l,(ix+coldboot)
	ld	h,(ix+coldboot+1)

	jp	(hl)		; und CP/M 3.1 starten


;--------------------------------------------------------------------------
;--------------------------------------------------------------------------
;--------------------------------------------------------------------------
;
; subroutines
;

testcopyright:
	;
	; Test for copyright message.
	; If none is present then it is likely no CPM3.SYS was appended.
	;
	; TESTCPM3.COM is created with "PIP testcpm3.com=bootsys.com[o],cpm3.sys[o].

	ld	hl,CPM3SYS+copyrmsg
	ld	de,CopyDRI
	ld	bc,CDRIlen - CopyDRI

cloop:	ld	a,(de)
	cpi			; vergleich A mit (HL) (A-(HL), HL++, BC--)
	inc	de
	ret	nz		; nz --> nocopyright
	jp	pe,cloop	; p=odd (gesetzt)? --> BC=0 --> Alle
				; character sind identisch --> go on
	xor	a		; z, copyright found
	ret			;


loadcpmsys:
	; load file from 1st argument, check for CPM3.SYS format in
	ld 	de,cpmfcb	; point at file control block
	ld	C,OPEN		; try to open file
	call	BDOS
	cp	0ffh 		; error?
	jr	nz,lcs1		; no, found

	ld	hl,nofilems	; error exit
	jp	PRSTRexit
;
lcs1:
	ld	hl,CPM3SYS
	ld	(dmaaddr),hl

rdloop:
	ld	de,(dmaaddr)
	ld	c,STDMA
	call	BDOS
;
	ld	c,READ		; read one record
	ld	de,cpmfcb	;
	call	BDOS
	or	a		; EOF: NZ (also clear CY)
	ret	nz

	ld	hl,(dmaaddr)
	ld	bc,128
	add	hl,bc
	ld	(dmaaddr),hl
	bit	7,h
	jr	nz,overrun	; >= 8000H
	ld	bc,CPM3SYS+80H
	sbc	hl,bc
	jr	nz,rdloop
	call	testcopyright	; CP/M message in 1st record?
	jr	Z,rdloop	; yes

	ld	hl,nocopyright2 ; no, exit with error
	jr	PRSTRexit

overrun:
	ld	hl,overrunms
	jr	PRSTRexit


transfer:
	; Copy <A> logical sectors from (HL) to (DE)
	ex	de,hl		; destination -> HL
	ld	bc,-80h
	add	hl,bc		;
	ex	de,hl		; 1st block
trans1: ld	bc,80h		; size
	ldir			; cp (HL)-->(DE)
	dec	d		; destination - 100h
	dec	a		; count
	jr	nz,trans1
	ret

PRSTRexit:
	call	PRSTRfunc	; exit with error message
	jp	wboot

PRSTRfunc:
	ld	a,(hl)
	cp	'$'
	ret	z		; if ch='$' --> return
	push	hl		; HL can be modified by cout
	ld	c,a
	call	cout		; call cout in CP/M-bios or yaze-bios direkt
	pop	hl
	inc	hl		; pointer to the next char
	jr	PRSTRfunc

    ifdef	LINUX

cout:
	; cout im BIOS aufrufen

	ld	hl,(wbvektor)
	ld	de,3*3		; 3rd vector after wboot
	add	hl,de
	jp	(hl)		; return address is on the stack

    else

cout:				; CONSOLE OUTPUT (Z80-MBC2-NG)
	call	cost		; space avail?
	; or	a		; A=0, Z flag set
	jr	z,cout		; no, loop until ready
	ld	a,(txavail)	; available char account
	dec	a		; adjust for one read char
	ld	(txavail),a	; update buffer account
	ld	a, sertx$opc	; A = SERIAL TX opcode
	out	(sto$opcd),a	; Write the opcode
	ld	a, c
	out	(exc$wr$opcd),a	; Send A to serial Tx
	ret

cost:				; CONSOLE OUTPUT STATUS (Z80-MBC2-NG)
	ld	a,(txavail)	; buffered number of tx free space
	or	a		; = 0?
	jr	nz,cost$1	; no
	ld	a, atxbuff$opc	; get current TX free space from IOS
	out	(sto$opcd),a	; write the opcode
	in	a,(exc$rd$opcd)	; read number into A
	or	a		; still zero?
	ret	z		; return CP/M not ready flag ($00)
				;
	ld	(txavail),a	; else update bios account
cost$1:
	ld	a, 0ffh		; return CP/M ready flag ($FF)
	ret

txavail:
	defb	0		; bios account for free space

    endif

; ============================================
; Print hl as 4-digit hex number
; ============================================
DispHLhex:
	ld	a,h
	call	DispAhex
	ld	a,l
	; fall through

DispAhex:
	push	AF
	rrca
	rrca
	rrca
	rrca
	call	DispAhex1
	pop	AF
	; fall through

DispAhex1:
	and	0FH
	cp	10
	jr	C,isdigit
	add	A,'A'-10
	jr	PRTchar
isdigit:
	add	A,'0'
PRTchar:
	push	hl
	ld	c,a
	call	cout
	pop	hl
	ret

; ============================================
; Print HL as decimal number (0-65535)
; ============================================
;Number in HL to decimal ASCII
;inputs:  HL = number to ASCII
;example: HL=300 outputs '00300'
;destroys: AF, BC, DE, HL
DispHL:
	ld	de,-10000
	call	Num1
	ld	de,-1000
	call	Num1
	ld	de,-100
	call	Num1
	ld	e,-10
	call	Num1
	ld	e,-1
Num1:	ld	a,'0'-1
Num2:	inc	a
	add	hl,de
	jr	c,Num2
	sbc	hl,de
	call	PRTchar
	ret


;--------------------------------------------------------------------------

	; Die folgende Zeile darf nicht veraendert werden, denn
	; dieser wird zum Ueberpruefen der Copyright Message in CPM3.SYS
	; verwendet
	; the copyright message below must remain unmodified
	; b/c CPM3.SYS is tested against this string
CopyDRI:
	db	'Copyright (C) 1982, Digital Research'
CDRIlen	equ	$

no_xmove_message:
	db	cr,lf
	db	'CP/M 3.1 is running but your BIOS does not implement XMOVE.'
	db	cr,lf,lf
	db	'To load and start CP/M 3.1 from this file'
	db	' you must be running CP/M 2.2.',cr,lf,lf
	db	'$'

loadmsg:
	db	cr,lf,'Loading CP/M 3.1:'
newline:
	db	cr,lf,'$'

nofilems:
	db	cr,lf,'File not found.',cr,lf,lf,'$'

overrunms:
	db	cr,lf,'File too big.',cr,lf,lf,'$'

bank1_message:
	db	cr,lf
	db	'CP/M 3.1 is already running; bank 1 is selected!',cr,lf
	db	'Now move everything to bank 0.',cr,lf
	db	'$'

bank0_message:
	db	'Done, bank 0 is selected.',cr,lf
	db	'$'

nocopyright1:
	db	cr,lf
	db	'No signature found. It seems there is no CPM3.SYS attached.'
	db	cr,lf
	db	'Use "pip testcpm3.com=bootsys.com[o],cpm3.sys[o]" to attach a'
	db	' CP/M3',cr,lf
	db	'sysfile or append it as command line argument "bootsys cpm3.sys".',cr,lf,lf
	db	'$'

nocopyright2:
	db	cr,lf
	db	'Argument has not the correct CPM3.SYS format.'
	db	cr,lf,lf
	db	'$'

cpmvek:
	db	0	; Muss 0 sein, wird so erwartet !!!
wbvektor:
	dw	0	; Adresse des Warmboots
dmaaddr:
	dw	CPM3SYS

    rept	16
	db	0AAH		; initialized is better
    endm

lstack:			; for the next instruction


CPM3SYS equ	($+7Fh) and 0FF80h

    rept	CPM3SYS-$
	db	0		; fill to the end
    endm

	end
